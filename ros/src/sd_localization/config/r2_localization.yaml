r2_localization_odom:
  # The real-valued frequency, in Hz, 
  # at which the filter produces a state estimate
  frequency: 10

  # The real-valued period, in seconds, 
  # after which we consider any sensor to have timed out
  sensor_timeout: 0.2

  # If true, do not estimate altitude
  two_d_mode: true
  
  # map frame is calculated after this filter
  # so we use the "improved odom mode" 
  # This is the most common mode
  odom_frame: r2/odom
  base_link_frame: r2/base_link
  world_frame: r2/odom

  # Some packages require that your transforms are 
  # future-dated by a small time offset. The value of this 
  # parameter will be added to the timestamp of map->odom 
  # or odom->base_link transform being generated by the 
  # state estimation nodes in robot_localization
  # AMCL requires this (next stage in the robot)
  transform_time_offset: 0.05 # 50ms

  # The robot_localization package uses tf2’s lookupTransform
  # method to request transformations. This parameter specifies
  # how long we would like to wait if a transformation is not 
  # available yet. Defaults to 0 if not set. The value 0 means 
  # we just get us the latest available (see tf2 implementation) 
  # transform so we are not blocking the filter. Specifying a 
  # non-zero transform_timeout affects the filter’s timing since 
  # it waits for a maximum of the transform_timeout for a transform
  # to become available. This directly implies that mostly the 
  # specified desired output rate is not met since the filter 
  # has to wait for transforms when updating.
  transform_timeout: 0
  
  # *_config :
  # The order of the boolean values are 
  # X,Y,Z,
  # roll,pitch,yaw,
  # X˙,Y˙,Z˙,
  # roll˙,pitch˙,yaw˙,
  # X¨,Y¨,Z¨. 

  # *_queue_size
  # Users can use these parameters to adjust the callback queue sizes
  #  for each sensor. This is useful if your frequency parameter 
  # value is much lower than your sensor’s frequency, as it allows 
  # the filter to incorporate all measurements that arrived in 
  # between update cycles.

  # *_nodelay
  # If true, sets the tcpNoDelay transport hint. There is some evidence
  # that Nagle’s algorithm intereferes with the timely reception of 
  # large message types, such as the nav_msgs/Odometry message. 
  # Setting this to true for an input disables Nagle’s algorithm for 
  # that subscriber. 

  odom0: mobile_base_controller/odom
  odom0_config: [true, true, false,
                 false, false, true,
                 true,  true, false,
                 false, false, false,
                 false, false, false]
  odom0_queue_size: 5 # Odom is 50Hz, filter is 10Hz
  odom0_nodelay: true
  
  initial_state: [0.0, 0.0, 0.0,
                  0.0, 0.0, 0.0,
                  0.0, 0.0, 0.0,
                  0.0, 0.0, 0.0,
                  0.0 ,0.0, 0.0]

  # Use this filter to publish odom TF     
  publish_tf: true
  publish_acceleration: false
  print_diagnostics: false
  
  # Do not use control to derive acceleration as
  # an IMU is configured an it overides the value
  use_control: false
  
  # False because all the defined sensors are real time
  smooth_lagged_data: false

  # Represents the natural noise in this mesure
  #                          X,     Y,    Z,   roll, pitch, yaw,  X˙,    Y˙,    Z˙,  roll˙, pitch˙,yaw˙,X¨,   Y¨,   Z¨. 
  process_noise_covariance: [0.01,  0,    0,    0,    0,    0,    0,     0,     0,    0,    0,    0,    0,    0,    0,
                              0,    0.01, 0,    0,    0,    0,    0,     0,     0,    0,    0,    0,    0,    0,    0,
                              0,    0,    1e-3, 0,    0,    0,    0,     0,     0,    0,    0,    0,    0,    0,    0,
                              0,    0,    0,    1e-3, 0,    0,    0,     0,     0,    0,    0,    0,    0,    0,    0,
                              0,    0,    0,    0,    1e-3, 0,    0,     0,     0,    0,    0,    0,    0,    0,    0,
                              0,    0,    0,    0,    0,    0.01, 0,     0,     0,    0,    0,    0,    0,    0,    0,
                              0,    0,    0,    0,    0,    0,    0.05,  0,     0,    0,    0,    0,    0,    0,    0,
                              0,    0,    0,    0,    0,    0,    0,     0.05,  0,    0,    0,    0,    0,    0,    0,
                              0,    0,    0,    0,    0,    0,    0,     0,     1e-3, 0,    0,    0,    0,    0,    0,
                              0,    0,    0,    0,    0,    0,    0,     0,     0,    1e-3, 0,    0,    0,    0,    0,
                              0,    0,    0,    0,    0,    0,    0,     0,     0,    0,    1e-3, 0,    0,    0,    0,
                              0,    0,    0,    0,    0,    0,    0,     0,     0,    0,    0,    0.01, 0,    0,    0,
                              0,    0,    0,    0,    0,    0,    0,     0,     0,    0,    0,    0,    0.01, 0,    0,
                              0,    0,    0,    0,    0,    0,    0,     0,     0,    0,    0,    0,    0,    0.01, 0,
                              0,    0,    0,    0,    0,    0,    0,     0,     0,    0,    0,    0,    0,    0,    1e-3]
  
  
  # Here's the rule you should follow: if you are measuring a variable, make the diagonal value in initial_estimate_covariance
  # larger than that measurement's covariance. So, for example, if your measurement's covariace value for the variable in 
  # question is 1e-6, make the initial_estimate_covariance diagonal value 1e-3 or something. This will speed up convergence. 
  # If you are not measuring a given variable (e.g., roll), make the diagonal value in initial_estimate_covariance small (but never zero).
  # Initial estimate :
  #  - two small : filter prefers its own estimate to the mesure -> slow convergence
  #  - two big : filter prefers the mesure over its estimate-> could diverge
  # Should be realistic for good performance
  #                             X,     Y,    Z,   roll, pitch, yaw,  X˙,    Y˙,    Z˙,  roll˙, pitch˙,yaw˙,X¨,   Y¨,   Z¨. 
  initial_estimate_covariance: [0.1,  0,    0,    0,    0,    0,    0,    0,    0,    0,     0,     0,     0,    0,    0,
                                0,    0.1,  0,    0,    0,    0,    0,    0,    0,    0,     0,     0,     0,    0,    0,
                                0,    0,    1e-6, 0,    0,    0,    0,    0,    0,    0,     0,     0,     0,    0,    0,
                                0,    0,    0,    1e-6, 0,    0,    0,    0,    0,    0,     0,     0,     0,    0,    0,
                                0,    0,    0,    0,    1e-6, 0,    0,    0,    0,    0,     0,     0,     0,    0,    0,
                                0,    0,    0,    0,    0,    0.1,  0,    0,    0,    0,     0,     0,     0,    0,    0,
                                0,    0,    0,    0,    0,    0,    0.1,  0,    0,    0,     0,     0,     0,    0,    0,
                                0,    0,    0,    0,    0,    0,    0,    0.1,  0,    0,     0,     0,     0,    0,    0,
                                0,    0,    0,    0,    0,    0,    0,    0,    1e-6, 0,     0,     0,     0,    0,    0,
                                0,    0,    0,    0,    0,    0,    0,    0,    0,    1e-6,  0,     0,     0,    0,    0,
                                0,    0,    0,    0,    0,    0,    0,    0,    0,    0,     1e-6,  0,     0,    0,    0,
                                0,    0,    0,    0,    0,    0,    0,    0,    0,    0,     0,     0.1,   0,    0,    0,
                                0,    0,    0,    0,    0,    0,    0,    0,    0,    0,     0,     0,     0.1,  0,    0,
                                0,    0,    0,    0,    0,    0,    0,    0,    0,    0,     0,     0,     0,    0.1,  0,
                                0,    0,    0,    0,    0,    0,    0,    0,    0,    0,     0,     0,     0,    0,    1e-9]





r2_localization_map:
  frequency: 10
  sensor_timeout: 0.2
  two_d_mode: true
  
  map_frame: map
  odom_frame: r2/odom
  base_link_frame: r2/base_link
  world_frame: map

  transform_time_offset: 0.05 # 50ms
  transform_timeout: 0.1
  
  pose0: amcl_pose
  pose0_config: [true, true, false,
                 false, false, true,
                 false,  false, false,
                 false, false, false,
                 false, false, false]

  odom0: mobile_base_controller/odom
  odom0_config: [true, true, false,
                 false, false, true,
                 true,  true, false,
                 false, false, false,
                 false, false, false]
  # AMCL should be the only source for pose, 
  # so odom is used as "differential" (only for speed)
  # odom0_differetial: true
  odom0_queue_size: 5 # Odom is 50Hz, filter is 10Hz
  odom0_nodelay: true
  
  initial_state: [0.0, 0.0, 0.0,
                  0.0, 0.0, 0.0,
                  0.0, 0.0, 0.0,
                  0.0, 0.0, 0.0,
                  0.0 ,0.0, 0.0]

  # Use this filter to publish map TF     
  publish_tf: false
  publish_acceleration: false
  print_diagnostics: true
  
  # Do not use control to derive acceleration as
  # an IMU is configured an it overides the value
  use_control: false
  
  # True : AMCL position computation time
  #smooth_lagged_data: true

  # If smooth_lagged_data is set to true, this parameter 
  # specifies the number of seconds for which the filter 
  # will retain its state and measurement history. This value 
  # should be at least as large as the time delta between y
  # our lagged measurements and the current time.
  #history_length: 2

  #                          X,     Y,    Z,   roll, pitch, yaw,  X˙,    Y˙,    Z˙,  roll˙, pitch˙,yaw˙,X¨,   Y¨,   Z¨. 
  process_noise_covariance: [0.01,  0,    0,    0,    0,    0,    0,     0,     0,    0,    0,    0,    0,    0,    0,
                              0,    0.01, 0,    0,    0,    0,    0,     0,     0,    0,    0,    0,    0,    0,    0,
                              0,    0,    1e-3, 0,    0,    0,    0,     0,     0,    0,    0,    0,    0,    0,    0,
                              0,    0,    0,    1e-3, 0,    0,    0,     0,     0,    0,    0,    0,    0,    0,    0,
                              0,    0,    0,    0,    1e-3, 0,    0,     0,     0,    0,    0,    0,    0,    0,    0,
                              0,    0,    0,    0,    0,    0.01, 0,     0,     0,    0,    0,    0,    0,    0,    0,
                              0,    0,    0,    0,    0,    0,    0.05,  0,     0,    0,    0,    0,    0,    0,    0,
                              0,    0,    0,    0,    0,    0,    0,     0.05,  0,    0,    0,    0,    0,    0,    0,
                              0,    0,    0,    0,    0,    0,    0,     0,     1e-3, 0,    0,    0,    0,    0,    0,
                              0,    0,    0,    0,    0,    0,    0,     0,     0,    1e-3, 0,    0,    0,    0,    0,
                              0,    0,    0,    0,    0,    0,    0,     0,     0,    0,    1e-3, 0,    0,    0,    0,
                              0,    0,    0,    0,    0,    0,    0,     0,     0,    0,    0,    0.01, 0,    0,    0,
                              0,    0,    0,    0,    0,    0,    0,     0,     0,    0,    0,    0,    0.01, 0,    0,
                              0,    0,    0,    0,    0,    0,    0,     0,     0,    0,    0,    0,    0,    0.01, 0,
                              0,    0,    0,    0,    0,    0,    0,     0,     0,    0,    0,    0,    0,    0,    1e-3]
  
  #                             X,     Y,    Z,   roll, pitch, yaw,  X˙,    Y˙,    Z˙,  roll˙, pitch˙,yaw˙,X¨,   Y¨,   Z¨. 
  initial_estimate_covariance: [0.1,  0,    0,    0,    0,    0,    0,    0,    0,    0,     0,     0,     0,    0,    0,
                                0,    0.1,  0,    0,    0,    0,    0,    0,    0,    0,     0,     0,     0,    0,    0,
                                0,    0,    1e-6, 0,    0,    0,    0,    0,    0,    0,     0,     0,     0,    0,    0,
                                0,    0,    0,    1e-6, 0,    0,    0,    0,    0,    0,     0,     0,     0,    0,    0,
                                0,    0,    0,    0,    1e-6, 0,    0,    0,    0,    0,     0,     0,     0,    0,    0,
                                0,    0,    0,    0,    0,    0.1,  0,    0,    0,    0,     0,     0,     0,    0,    0,
                                0,    0,    0,    0,    0,    0,    0.1,  0,    0,    0,     0,     0,     0,    0,    0,
                                0,    0,    0,    0,    0,    0,    0,    0.1,  0,    0,     0,     0,     0,    0,    0,
                                0,    0,    0,    0,    0,    0,    0,    0,    1e-6, 0,     0,     0,     0,    0,    0,
                                0,    0,    0,    0,    0,    0,    0,    0,    0,    1e-6,  0,     0,     0,    0,    0,
                                0,    0,    0,    0,    0,    0,    0,    0,    0,    0,     1e-6,  0,     0,    0,    0,
                                0,    0,    0,    0,    0,    0,    0,    0,    0,    0,     0,     0.1,   0,    0,    0,
                                0,    0,    0,    0,    0,    0,    0,    0,    0,    0,     0,     0,     0.1,  0,    0,
                                0,    0,    0,    0,    0,    0,    0,    0,    0,    0,     0,     0,     0,    0.1,  0,
                                0,    0,    0,    0,    0,    0,    0,    0,    0,    0,     0,     0,     0,    0,    1e-9]


r2_amcl:
  # Minimum allowed number of particles
  min_particles: 100

  # Maximum allowed number of particles (default : 5000)
  max_particles: 2500

  # Translational movement required before performing 
  # a filter update (in meter)
  update_min_d: 0.05

  # Rotational movement required before performing 
  # a filter update (radian)
  update_min_a: 0.1

  # Number of filter updates required before resampling
  resample_interval: 10

  # Time with which to post-date the transform that is 
  # published, to indicate that this transform is valid into the future
  transform_tolerance: 0.2

  # Disable the "add random poses" mecanism
  recovery_alpha_slow: 0.0
  recovery_alpha_fast: 0.0

  # Limit the GUI refresh rate at 2Hz
  gui_publish_rate: 2

  # Disable : Consequent run pose "backup and restore"
  # using the parameter server
  save_pose_rate: -1

  # Use map topic instead of a service call (new)
  use_map_topic: true

  # Use only the first mal received (do not update during execution)
  first_map_only: false

  # -1 means the laser's reported minimum range to be used
  laser_min_range: -1.0

  # -1 means the laser's reported maximum range to be used
  laser_max_range: -1.0

  # How many evenly-spaced beams in each scan to be used when 
  # updating the filter (30 means one every 12°)
  laser_max_beams: 30

  # Beamskip is an optimization algorithm (CPU usage)
  do_beamskip: true

  # A beam is considered not to match the map if its distance 
  # to the closest occupied cell in the map is >= beam_skip_distance
  beam_skip_distance: 0.3

  # A beam is skipped if a there are enough particles at which the 
  # beam does not match the map. The minimum ratio of particles for
  #  which a beam must match the map in order not be skipped is specified
  # by the beam_skip_threshold parameter
  beam_skip_threshold: 0.1
  
  # Use omnidirectionnal robot (fixed version)
  odom_model_type: "diff-corrected"
  
  odom_frame_id: r2/odom
  base_frame_id: r2/base_link
  global_frame_id: map

  # TF is broadcasted by the UKF filter
  tf_broadcast: true

r2_snap_map:
  active: false

  odom_frame: r2/odom
  laser_frame: r2/lidar_link
  base_frame: r2/base_link
  map_frame: map  

  scan_rate: 2.0

  # describes how old laser scans can be before they get sorted out 
  # by SnapMap (seconds)
  age_threshold: 1.0

  # how long before another, new initial pose will 
  # be sent after one was sent (seconds)
  update_age_threshold: 1.0

  # meters distance a point can have to its nearest neighbor in map to 
  # be still considered as inlier
  icp_inlier_dist: 0.1

  # percentage of scan points that must match withing icp_inlier_dist
  # so that the match is considered good and a initial pose can be sent
  icp_inlier_threshold: 0.9

  # number of iterations in ICP
  icp_num_iter: 250

  # icp transform angle that will still be considered a sane match 
  # published as an initial pose.
  angle_upper_threshold: 0.5236 #pi/6

  # minimum position change that will trigger a re-initialisation of amcl (meter)
  dist_change_threshold: 0.05

  # minimum angle change that will trigger a re-initialisation of amcl (radian)
  angle_change_threshold: 0.01
  
  # Translational pose covariance when the initial pose is sent
  pose_covariance_trans: 1.5

  # Publish a monitoring topic
  publish_monitoring: true